---
title: Java类加载
date: 2021-04-28 21:00:58
tags: Java
---
JVM的类加载是通过ClassLoader及其子类来完成的，是虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型的过程。另外，类型的加载、连接和初始化过程都是在程序运行期完成的，从而通过牺牲一些性能开销来换取Java程序的高度灵活性。
<!--more-->
# 类加载器种类
- 启动类加载器，Bootstrap ClassLoader，加载JACA_HOME\lib，或者被-Xbootclasspath参数限定的类
- 扩展类加载器，Extension ClassLoader，加载\lib\ext，或者被java.ext.dirs系统变量指定的类
- 应用程序类加载器，Application ClassLoader，加载ClassPath中的类库
- 自定义类加载器，通过继承ClassLoader实现，一般是加载我们的自定义类

# 类加载过程
- 加载
    - 把class字节码文件从各个来源通过类加载器装载入内存中。
        - 字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
        - 类加载器。一般包括启动类加载器，扩展类加载器，应用类加载器，以及用户的自定义类加载器。
    - 在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情
        - 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；
        - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
        - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
    - 加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。
- 链接
    - 验证
        - 主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。
        - 包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？
        - 对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？
        - 对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。
        - 对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？
    - 准备
        - 主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值。
        - 特别需要注意，初值，不是代码中具体写的初始化的值，而是Java虚拟机根据不同变量类型的默认初始值。
        - 比如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值，final static a = 123， 那么该阶段a的初值就是123
    - 解析
        - 将常量池内的符号引用替换为直接引用的过程。
        - 两个重点：
            - 符号引用。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
            - 直接引用。可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量
        - 举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。
        - 在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。
- 初始化
    - 这个阶段主要是对类变量初始化，是执行类构造器的过程。
    - 换句话说，只对static修饰的变量或语句进行初始化。
    - 如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。
    - 如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

# 双亲委派机制
主要是表示类加载器之间的层次关系
- 前提：除了顶层启动类加载器外，其余类加载器都应当有自己的父类加载器，且它们之间关系一般不会以继承（Inheritance）关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。
- 工作过程：若一个类加载器收到了类加载的请求，它先会把这个请求委派给父类加载器，并向上传递，最终请求都传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

# 通过下面一个代码案例理解类加载顺序？当遇到 类名.变量 加载时，只加载变量所在类吗
```
class A{
    public static int value = 134;
    static{
        System.out.println("A");
    }
}

class B extends  A{
    static{
        System.out.println("B");
    }
}


public class Demo {
   public static void main(String args[]){
       int s = B.value;
       System.out.println(s);
   }
}
//a.打印错误结果
A 
B
134 
//b.打印正确结果
A
134 
```
当遇到 类名.变量 加载时，只加载变量所在类

如何做才能打印a这种结果呢？
```
class A{
    public static int valueA = 134;
    static{
        System.out.println("A");
    }
}

class B extends  A{
    public static int valueB = 245;
    static{
        System.out.println("B");
    }
}

public class Demo {
   public static void main(String args[]){
       int s = B.valueB;
       System.out.println(s);
   }
}
```

# 看下面这段代码，说一下准备阶段和初始化阶段常量变化的原理？
```
public static int value1  = 5;
public static int value2  = 6;
static{
    value2 = 66;
}
```
- 在准备阶段value1和value2都等于0；
- 在初始化阶段value1和value2分别等于5和66；
## 变量初始化过程
- 所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，存放到一个特殊的方法中，这个方法就是方法，即类/接口初始化方法，该方法只能在类加载的过程中由JVM调用；
- 编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量；
- 如果超类还没有被初始化，那么优先对超类初始化，但在方法内部不会显示调用超类的方法，由JVM负责保证一个类的方法执行之前，它的超类方法已经被执行。
- JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。(所以可以利用静态内部类实现线程安全的单例模式)
- 如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类方法；