---
title: Java虚拟机
date: 2021-04-28 20:43:27
tags: Java
---
JVM(Java Virtual Machine，Java虚拟机),它是由软件技术模拟出计算机运行的一个虚拟的计算机。JVM也充当着一个翻译官的角色，我们编写出的Java程序，是不能够被操作系统所直接识别的，由JVM负责把程序翻译给系统“听”，告诉它我们的程序需要做什么操作。

JVM在每个操作系统中有其对应的Java解释器，解释器会将Java程序经过编译后产生的.Class文件解释成特定的机器码，被操作系统所识别，实现一次编译到处运行。
<!--more-->
# 数据区域
- 方法区
    - 在JVM中，类型信息和类静态变量都保存在方法区中，类型信息是由类加载器在类加载的过程中从类文件中提取出来的信息。
    - 需要注意的一点是，常量池也存放于方法区中。
    - 程序中所有的线程共享一个方法区，所以访问方法区的信息必须确保线程是安全的。如果有两个线程同时去加载一个类，那么只能有一个线程被允许去加载这个类，另一个必须等待。
- 堆区
    - 当Java创建一个类的实例对象或者数组时，都在堆中为新的对象分配内存。
    - 虚拟机中只有一个堆，程序中所有的线程都共享它。
- 栈区
    - 在Java栈中只保存基础数据类型和自定义对象的引用，注意只是对象的引用而不是对象本身哦，对象是保存在堆区中的。
    - 像String、Integer、Byte、Short、Long、Character、Boolean这六个属于包装类型，它们是存放于堆中的。
    - 栈内的数据在超出其作用域后，会被自动释放掉，它不由JVM GC管理。
    - 每一个线程都包含一个栈区，每个栈中的数据都是私有的，其他栈不能访问。
- 本地方法栈：专门为native方法服务的，例如：C、C++方法，线程私有
- 程序计数器(PC Register)：保存当前线程执行的内存地址。由于JVM程序是多线程执行的，所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录中断的地方，可见程序计数器也是线程私有的

## 对象的创建过程
比如：Dog dog= new Dog()；
- 当虚拟机执行到new指令时，它先在常量池中查找“Dog”，看能否定位到Dog类的符号引用；如果能，说明这个类已经被加载到方法区了，则继续执行。如果没有，就让Class Loader先执行类的加载。
- 然后，虚拟机开始为该对象分配内存，对象所需要的内存大小在类加载完成后就已经确定了。这时候只要在堆中按需求分配空间即可。具体分配内存时有两种方式，第一种，内存绝对规整，那么只要在被占用内存和空闲内存间放置指针即可，每次分配空间时只要把指针向空闲内存空间移动相应距离即可，当某对象被GC回收后，则需要进行某些对象内存的迁移。第二种，空闲内存和非空闲内存夹杂在一起，那么就需要用一个列表来记录堆内存的使用情况，然后按需分配内存。
- 对于多线程的情况，如何确保一个线程分配了对象内存但尚未修改内存管理指针时，其他线程又分配该块内存而覆盖的情况？有一种方法，就是让每一个线程在堆中先预分配一小块内存（TLAB本地线程分配缓冲），每个线程只在自己的内存中分配内存。但对象本身按其访问属性是可以线程共享访问的
- 内存分配到后，虚拟机将分配的内存空间都初始化为零值(不包括对象头)。实例变量按变量类型初始化相应的默认值（数值型为0，boolan为false），所以实例变量不赋初值也能使用。接着设置对象头信息，比如对象的哈希值，GC分代年龄等。
- 从虚拟机角度，此时一个新的对象已经创建完成了。但从我们程序运行的角度，新建对象才刚刚开始，对象的构造方法还没有执行。只有执行完构造方法，按构造方法进行初始化后，对象才是彻底创建完成了。构造函数的执行还涉及到调用父类构造器，如果没有显式声明调用父类构造器，则自动添加默认构造器
- new运算符可以返回堆中这个对象的引用

## 变量创建过程种放在虚拟机哪里
- 如果dog局部变量，dog变量在栈帧的局部变量表，这个对象的引用就放在栈帧。
- 如果dog是实例变量，dog变量在堆中，对象的引用就放在堆。
- 如果dog是静态变量，dog变量在方法区，对象的引用就放在方法区。

## OutOfMemoryError异常在哪些数据区域中可能会出现
- Java堆溢出
```
public void testd() {
    List<String> list = new ArrayList<>();
    int i = 0;
    while (true) {
        list.add(new String(i + ""));
        i++;
    }
}
```
- 虚拟机栈和本地方法栈溢出
```
//栈内存溢出
public void A() {
    A();
}
```
- 方法区和运行时常量池溢出

# JVM GC（垃圾回收机制）

## 对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存
当一个对象的引用变为null时，并不会被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存

## 垃圾收集的方法
- 标记-清除
    - 这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次GC动作。
- 复制算法
    - 为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。
    - 于是将该算法进行了改进，内存区域不再是按照1：1去划分，而是将内存划分为8:1:1三部分，较大那份内存交Eden区，其余是两块较小的内存区叫Survior区。每次都会优先使用Eden区，若Eden区满，就将对象复制到第二块内存区上，然后清除Eden区，如果此时存活的对象太多，以至于Survivor不够时，会将这些对象通过分配担保机制复制到老年代中。(java堆又分为新生代和老年代)
- 标记-整理
    - 该算法主要是为了解决标记-清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
- 分代收集
    - 现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。

## 如和判断一个对象是否存活
- 引用计数法
    - 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.
    - 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法
- 可达性算法(引用链法)
    - 该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
    - 在java中可以作为GC Roots的对象有以下几种:
        - 虚拟机栈中引用的对象
        - 方法区类静态属性引用的对象
        - 方法区常量池引用的对象
        - 本地方法栈JNI引用的对象

## 如何理解一个对象不一定会被回收
- 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记
- 如果对象在可达性分析中没有与GCRoot的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。
- 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。