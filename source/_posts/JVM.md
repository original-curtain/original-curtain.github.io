---
title: JVM
date: 2021-04-26 13:14:00
tags: Java
---
JVM(Java Virtual Machine，Java虚拟机),它是由软件技术模拟出计算机运行的一个虚拟的计算机。JVM也充当着一个翻译官的角色，我们编写出的Java程序，是不能够被操作系统所直接识别的，由JVM负责把程序翻译给系统“听”，告诉它我们的程序需要做什么操作。

JVM在每个操作系统中有其对应的Java解释器，解释器会将Java程序经过编译后产生的.Class文件解释成特定的机器码，被操作系统所识别，实现一次编译到处运行。
<!--more-->
<https://zhuanlan.zhihu.com/p/25713880>

# 体系结构
- 类加载系统（ClassLoader）：在JVM启动时或者在类运行时将需要的class加载到JVM中。
- 内存空间（也叫运行时数据区）：是在JVM运行的时候所分配的内存区，运行时内存区主要可以划分为5个区域；
- 执行引擎：负责执行class文件中包含的指令；
- 本地库接口：主要是调用C或C++实现的本地方法及返回结果；

# 类加载子系统
<https://zhuanlan.zhihu.com/p/25228545>
## 加载器
JVM的类加载是通过ClassLoader及其子类来完成的
- Bootstrap ClassLoader 负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类
- Extension ClassLoader 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包。
- App ClassLoader 负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包
- Custom ClassLoader 通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

## 加载过程
- 装载：查找并加载类的二进制数据（查找和导入Class文件）
- 链接
    - 验证：确保被加载的类的正确性
    - 准备：为类的静态变量分配内存，并将其初始化为默认值
    - 解析：把类中的符号引用转换为直接引用
- 初始化：对类的静态变量，静态代码块执行初始化操作
    - 类什么时候才被初始化
        - 创建类的实例，也就是new一个对象
        - 访问某个类或接口的静态变量，或者对该静态变量赋值
        - 调用类的静态方法
        - 反射（Class.forName("com.lyj.load")）
        - 初始化一个类的子类（会首先初始化子类的父类
        - JVM启动时标明的启动类，即文件名和类名相同的那个类

# 内存分配
- 方法区
    - 在JVM中，类型信息和类静态变量都保存在方法区中，类型信息是由类加载器在类加载的过程中从类文件中提取出来的信息。
    - 需要注意的一点是，常量池也存放于方法区中。
    - 程序中所有的线程共享一个方法区，所以访问方法区的信息必须确保线程是安全的。如果有两个线程同时去加载一个类，那么只能有一个线程被允许去加载这个类，另一个必须等待。
- 堆区
    - 当Java创建一个类的实例对象或者数组时，都在堆中为新的对象分配内存。
    - 虚拟机中只有一个堆，程序中所有的线程都共享它。
- 栈区
    - 在Java栈中只保存基础数据类型和自定义对象的引用，注意只是对象的引用而不是对象本身哦，对象是保存在堆区中的。
    - 像String、Integer、Byte、Short、Long、Character、Boolean这六个属于包装类型，它们是存放于堆中的。
    - 栈内的数据在超出其作用域后，会被自动释放掉，它不由JVM GC管理。
    - 每一个线程都包含一个栈区，每个栈中的数据都是私有的，其他栈不能访问。
- 本地方法栈：专门为native方法服务的，例如：C、C++方法
- 程序计数器(PC Register)：保存当前线程执行的内存地址。由于JVM程序是多线程执行的，所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录中断的地方，可见程序计数器也是线程私有的

# JVM GC（垃圾回收机制）
<https://zhuanlan.zhihu.com/p/25539690>
## JVM GC回收哪个区域内的垃圾
JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内

## JVM GC怎么判断对象可以被回收了
- 对象没有引用
- 作用域发生未捕获异常
- 程序在作用域正常执行完毕
- 程序执行了System.exit()
- 程序发生意外终止（被杀线程等）

在Java程序中不能显式的分配和注销缓存，因为这些事情JVM都帮我们做了，那就是GC。

有些时候我们可以将相关的对象设置成null 来试图显示的清除缓存，但是并不是设置为null 就会一定被标记为可回收，有可能会发生逃逸。

将对象设置成null 至少没有什么坏处，但是使用System.gc() 便不可取了，使用System.gc() 时候并不是马上执行GC操作，而是会等待一段时间，甚至不执行，而且System.gc() 如果被执行，会触发Full GC ，这非常影响性能。

## 按代的垃圾回收机制
- 新生代（Young generation）：绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后“消失”。对象从这个区域“消失”的过程我们称之为：Minor GC 
- 老年代（Old generation）：对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：Major GC 或者 Full GC。
- 持久代（Permanent generation）也称之为 方法区（Method area）：用于保存类常量以及字符串常量。注意，这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为 Major GC 。只不过在这个区域发生GC的条件非常严苛，必须符合以下三种条件才会被回收：
    1. 所有实例被回收
    2. 加载该类的ClassLoader 被回收
    3. Class 对象无法通过任何途径访问（包括反射）

