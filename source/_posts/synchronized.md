---
title: synchronized
date: 2021-04-22 10:58:27
tags: Java
---
# 主要规则
1. 当两个或者多个并发线程同时访问一个object中的synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行，其他线程必须要等到当前线程执行完这个代码块之后才能继续执行该代码块。
2. 然而，当一个线程访问object中的synchronized(this)同步代码块时，其他线程仍然可以调用object中的其它非synchronized(this)同步代码块。
3. 尤其关键的是，当一个线程访问object中的一个synchronized(this)同步代码块时，其他线程对于object中的其它synchronized(this)同步代码块的访问，都将被阻塞。
4. 第3条中的说明同样适用于其它同步代码块，也就是说，当一个线程访问object中的一个synchronized(this)同步代码块时，它就获得了整个object的对象锁，因此，其他所有线程对于object的所有同步代码块的访问都将被暂时阻塞，直至当前线程执行完这个代码块。
5. 上述的规则对于其他对象锁也同样适用。

# synchronized方法
每一个类实例都对应一把锁，每个synchronized方法的执行都必须要获得调用该方法的类的实例的锁，才能执行，否则，线程就会阻塞。而方法一旦开始执行，就会独占该锁，直到方法执行完成返回后释放该锁，然后阻塞的线程就获取锁，然后调用方法执行。

这种机制确保了同一时刻对于每一个类的实例来讲，只有一个synchronized方法处于正在执行状态，因为同一时间最多只能有一个线程获取到类的实例的锁。这能确保类成员变量的访问冲突问题，前提是我们将所有可能冲突的方法声明为synchronized方法。

在java中，不仅仅是类的实例，类也有锁，我们可以将类的静态变量声明上添加synchronized关键字，这样就能控制线程对于类静态成员变量的访问。

缺点：将方法声明为synchronized会影响效率。例如，如果我们想线程类的run()方法定义为synchronized的，则在线程的整个生命周期内，它都会一直运行，且它无法调用本类任何synchronized方法，因为一直占用锁。所以我们可以将访问成员变量部分的代码定义为单独的方法，然后将这个方法声明为synchronized即可。

# synchronized块

我们同样可以通过使用synchronized关键字声明一个synchronized块，代码如下
```
    synchronized (inner) {
        //需要进行访问控制的代码
    }
```
上述代码中的inner可以为类，也可以为类的实例，具体实现可以如下所示，此种方式同synchronized进行比较的话，更为灵活，我们可以根据实际的需要对于想要添加锁的代码或类加锁。